package org.irisacsee.trajlab.query;

import com.google.protobuf.ByteString;
import lombok.extern.slf4j.Slf4j;
import org.apache.hadoop.hbase.TableName;
import org.irisacsee.trajlab.constant.QueryConstant;
import org.irisacsee.trajlab.index.IndexType;
import org.irisacsee.trajlab.index.type.RowKeyRange;
import org.irisacsee.trajlab.meta.DataSetMeta;
import org.irisacsee.trajlab.meta.IndexMeta;
import org.irisacsee.trajlab.model.Trajectory;
import org.irisacsee.trajlab.model.TrajectoryWithDistance;
import org.irisacsee.trajlab.query.condition.KNNQueryCondition;
import org.irisacsee.trajlab.query.condition.SpatialQueryCondition;
import org.irisacsee.trajlab.query.condition.SpatialTemporalQueryCondition;
import org.irisacsee.trajlab.query.coprocessor.QueryProtoBuilder;
import org.irisacsee.trajlab.query.coprocessor.STCoprocessorQuery;
import org.irisacsee.trajlab.query.coprocessor.autogenerated.QueryCondition;
import org.irisacsee.trajlab.store.HBaseConnector;
import org.irisacsee.trajlab.util.GeoUtil;
import org.irisacsee.trajlab.util.SerializableBiFunction;
import org.locationtech.jts.geom.Geometry;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;

@Slf4j
public class WKNNQuery extends AbstractQuery<SpatialTemporalQueryCondition> {
    private static final double SQRT_2 = Math.sqrt(2);
    private double curSearchDist = QueryConstant.BASIC_BUFFER_DISTANCE;
    private double maxDistance = Double.MAX_VALUE;
    private final KNNQueryCondition knnCondition;
    private int stage;

    public WKNNQuery(DataSetMeta dataSetMeta, KNNQueryCondition knnCondition) {
        super(dataSetMeta, null);
        this.knnCondition = knnCondition;
        this.stage = 0;
    }

    private boolean hasTimeConstrain() {
        return knnCondition.getTemporalQueryCondition() != null;
    }

    @Override
    public List<Trajectory> runPartitioned() throws IOException {
        setupTarget();
//        target.setTable(HBaseConnector.getConnection().getTable(TableName.valueOf("T10-XZ2T-default")));
        switch (knnCondition.getKnnQueryType()) {
            case TRAJECTORY:
                return runOnCase();
            default:
                throw new UnsupportedOperationException();
        }
    }

    private List<RowKeyRange> getPartitionedRanges(Set<RowKeyRange> set, SpatialTemporalQueryCondition condition) {
        List<RowKeyRange> ranges = target
                .getIndexMeta()
                .getIndexStrategy()
                .getPartitionedScanRanges(condition);
        System.out.println("ranges size before: " + ranges.size());
        ranges.removeAll(set);
        System.out.println("ranges size after: " + ranges.size());
        set.addAll(ranges);
        return ranges;
    }

    public List<Trajectory> runOnCase() throws IOException {
        int k = knnCondition.getK(), resultSearch = 0, searchNothing = 0;
        PriorityQueue<TrajectoryWithDistance> pq = new PriorityQueue<>(
                k, Comparator.comparingDouble(TrajectoryWithDistance::getDistance));
        Set<RowKeyRange> set = new HashSet<>();
        while ((pq.size() < k && searchNothing < QueryConstant.MAX_QUERY_NOTHING_TIME) || (resultSearch != 0)) {
            System.out.println("c1: " + (pq.size() < k));
            System.out.println("c2: " + (searchNothing < QueryConstant.MAX_QUERY_NOTHING_TIME));
            System.out.println("c3: " + (resultSearch != 0));
            System.out.println("c1 && c2: " + (pq.size() < k && searchNothing < QueryConstant.MAX_QUERY_NOTHING_TIME));
            System.out.println("(c1 && c2) || c3: " + ((pq.size() < k && searchNothing < QueryConstant.MAX_QUERY_NOTHING_TIME) || (resultSearch != 0)));
            // 首先更新时空查询条件
            Geometry buffer = knnCondition.getCentralTrajectory().buffer(GeoUtil.getDegreeFromKm(curSearchDist));
            SpatialTemporalQueryCondition condition = new SpatialTemporalQueryCondition(
                    new SpatialQueryCondition(buffer, SpatialQueryCondition.SpatialQueryType.INTERSECT),
                    knnCondition.getTemporalQueryCondition()
            );
            System.out.println("sqc: " + condition.getSpatialQueryCondition());
            System.out.println("set size before: " + set.size());
            List<Trajectory> stageResult = execute(getPartitionedRanges(set, condition));
            System.out.println("set size after: " + set.size());
            addToHeap(k, pq, stageResult);
            resultSearch = stageResult.size();
            searchNothing = getSearchRadiusKM(k, resultSearch, searchNothing);
            if (!pq.isEmpty()) {
                maxDistance = pq.peek().getDistance();
            }
            ++stage;
            log.info("Start search radius {} at stage {}, got {} numbers count.",
                    curSearchDist, stage, resultSearch);
        }
        List<Trajectory> result = new ArrayList<>(pq.size());
        while (!pq.isEmpty()) {
            result.add(pq.poll().getTrajectory());
        }
        return result;
    }

    private void addToHeap(
            int k, PriorityQueue<TrajectoryWithDistance> pq, List<Trajectory> trajectories) {
        for (Trajectory t : trajectories) {
//            System.out.println("check: " + pq.size());
            TrajectoryWithDistance twd = new TrajectoryWithDistance(t, knnCondition.getCentralTrajectory());
            if (!pq.contains(twd)) {
                if (pq.size() < k) {
                    pq.offer(twd);
                } else if (pq.peek().getDistance() > twd.getDistance()) {
                    pq.poll();
                    pq.offer(twd);
                }
            }
        }
    }

    private int getSearchRadiusKM(int k, int resultSearch, int searchNothing) {
        if (resultSearch > 0) {
            double temp = k / (double) resultSearch;
            if (temp <= 10.0) {
                curSearchDist *= SQRT_2;
            } else {
                curSearchDist *= Math.sqrt(temp);
            }
        } else {
            curSearchDist *= SQRT_2;
            ++searchNothing;
        }
        return searchNothing;
    }

    @Override
    protected IndexMeta<SpatialTemporalQueryCondition> findBestIndex() {
        Map<IndexType, List<IndexMeta>> map = dataSetMeta.getAvailableIndexes();
        // case 1: 无时间约束，找XZ2索引
        if (!hasTimeConstrain()) {
            if (map.containsKey(IndexType.XZ2)) {
                return IndexMeta.getBestIndexMeta(map.get(IndexType.XZ2));
            }
        }
        // case 2: 有时间约束，找XZ2T索引或TXZ2索引
        else {
            if (map.containsKey(IndexType.XZ2T)) {
                return IndexMeta.getBestIndexMeta(map.get(IndexType.XZ2T));
            }
            if (map.containsKey(IndexType.TXZ2)) {
                return IndexMeta.getBestIndexMeta(map.get(IndexType.TXZ2));
            }
        }
        return null;
    }

    @Override
    protected String getQueryInfo() {
        return knnCondition.getConditionInfo();
    }

    private QueryCondition.QueryRequest buildQueryRequestCasePointHasTimeConstrain(
            QueryCondition.QueryRequest.Builder qrBuilder,
            QueryCondition.KNNQueryRequest.Builder kqrBuilder,
            QueryCondition.TemporalQueryWindow tqw) throws IOException {
        return qrBuilder
                .setKnn(kqrBuilder
                        .setPoint(ByteString.copyFrom(knnCondition.getPointBytes()))
                        .setTemporalQueryWindow(tqw)
                        .build())
                .build();
    }

    private QueryCondition.QueryRequest buildQueryRequestCasePointHasNotTimeConstrain(
            QueryCondition.QueryRequest.Builder qrBuilder,
            QueryCondition.KNNQueryRequest.Builder kqrBuilder) throws IOException {
        return qrBuilder
                .setKnn(kqrBuilder
                        .setPoint(ByteString.copyFrom(knnCondition.getPointBytes()))
                        .build())
                .build();
    }

    private QueryCondition.QueryRequest buildQueryRequestCaseTrajectoryHasTimeConstrain(
            QueryCondition.QueryRequest.Builder qrBuilder,
            QueryCondition.KNNQueryRequest.Builder kqrBuilder,
            QueryCondition.TemporalQueryWindow tqw) throws IOException {
        return qrBuilder
                .setKnn(kqrBuilder
                        .setTrajectory(ByteString.copyFrom(knnCondition.getTrajectoryBytes()))
                        .setTemporalQueryWindow(tqw)
                        .build())
                .build();
    }

    private QueryCondition.QueryRequest buildQueryRequestCaseTrajectoryHasNotTimeConstrain(
            QueryCondition.QueryRequest.Builder qrBuilder,
            QueryCondition.KNNQueryRequest.Builder kqrBuilder) throws IOException {
        return qrBuilder
                .setKnn(kqrBuilder
                        .setTrajectory(ByteString.copyFrom(knnCondition.getTrajectoryBytes()))
                        .build())
                .build();
    }


    @Override
    protected List<Trajectory> execute(List<RowKeyRange> rkRanges) throws IOException {
        List<QueryCondition.Range> ranges = rowKeyRangeToProtoRange(rkRanges);
        QueryCondition.TemporalQueryWindow tqw =
                QueryProtoBuilder.buildProtoTemporalWindow(knnCondition.getTemporalQueryCondition());
        QueryCondition.QueryRequest.Builder qrBuilder = QueryCondition.QueryRequest
                .newBuilder()
                .setQueryOperation(QueryCondition.QueryMethod.KNN)
                .addAllRange(ranges);
        QueryCondition.KNNQueryRequest.Builder kqrBuilder = QueryCondition.KNNQueryRequest
                .newBuilder()
                .setK(knnCondition.getK())
                .setDistance(GeoUtil.getDegreeFromKm(maxDistance));
        switch (knnCondition.getKnnQueryType()) {
            case POINT: {
                QueryCondition.QueryRequest knnQueryRequest;
                if (hasTimeConstrain()) {
                    knnQueryRequest = buildQueryRequestCasePointHasTimeConstrain(qrBuilder, kqrBuilder, tqw);
                } else {
                    knnQueryRequest = buildQueryRequestCasePointHasNotTimeConstrain(qrBuilder, kqrBuilder);
                }
                return STCoprocessorQuery.execute(target.getTable(), knnQueryRequest);
            }
            case TRAJECTORY: {
                QueryCondition.QueryRequest knnQueryRequest;
                if (hasTimeConstrain()) {
                    knnQueryRequest = buildQueryRequestCaseTrajectoryHasTimeConstrain(qrBuilder, kqrBuilder, tqw);
                } else {
                    knnQueryRequest = buildQueryRequestCaseTrajectoryHasNotTimeConstrain(qrBuilder, kqrBuilder);
                }
                return STCoprocessorQuery.execute(target.getTable(), knnQueryRequest);
            }
            default:
                throw new UnsupportedEncodingException();
        }
    }
}
