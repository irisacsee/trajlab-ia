package org.irisacsee.trajlab.query;

import com.google.protobuf.ByteString;
import lombok.extern.slf4j.Slf4j;
import org.apache.hadoop.hbase.TableName;
import org.apache.hadoop.hbase.client.Table;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.sql.SparkSession;
import org.irisacsee.trajlab.constant.QueryConstant;
import org.irisacsee.trajlab.index.IndexType;
import org.irisacsee.trajlab.index.type.RowKeyRange;
import org.irisacsee.trajlab.meta.DataSetMeta;
import org.irisacsee.trajlab.meta.IndexMeta;
import org.irisacsee.trajlab.model.BasePoint;
import org.irisacsee.trajlab.model.Trajectory;
import org.irisacsee.trajlab.model.TrajectoryWithDistance;
import org.irisacsee.trajlab.query.condition.KNNQueryCondition;
import org.irisacsee.trajlab.query.condition.SpatialQueryCondition;
import org.irisacsee.trajlab.query.condition.SpatialTemporalQueryCondition;
import org.irisacsee.trajlab.query.coprocessor.QueryProtoBuilder;
import org.irisacsee.trajlab.query.coprocessor.STCoprocessorQuery;
import org.irisacsee.trajlab.query.coprocessor.autogenerated.QueryCondition;
import org.irisacsee.trajlab.store.HBaseConnector;
import org.irisacsee.trajlab.util.GeoUtil;
import org.irisacsee.trajlab.util.SerializableBiFunction;
import org.locationtech.jts.geom.Geometry;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;

/**
 * KNN查询
 *
 * @author irisacsee
 * @since 2024/11/22
 */
@Slf4j
public class KNNQuery extends AbstractQuery<SpatialTemporalQueryCondition> {
    private static final double SQRT_2 = Math.sqrt(2);
    private static final SerializableBiFunction<
            KNNQueryCondition, Double, Geometry> GET_GEOMETRY_WINDOW_CASE_POINT =
            (c, d) -> c.getCentralPoint().buffer(GeoUtil.getDegreeFromKm(d));
    private static final SerializableBiFunction<
            KNNQueryCondition, Double, Geometry> GET_GEOMETRY_WINDOW_CASE_TRAJECTORY =
            (c, d) -> c.getCentralTrajectory().buffer(GeoUtil.getDegreeFromKm(d));
    private static final SerializableBiFunction<
            KNNQueryCondition, Trajectory, TrajectoryWithDistance> NEW_TWD_CASE_POINT =
            (c, t) -> new TrajectoryWithDistance(t, c.getCentralPoint());
    private static final SerializableBiFunction<
            KNNQueryCondition, Trajectory, TrajectoryWithDistance> NEW_TWD_CASE_TRAJECTORY =
            (c, t) -> new TrajectoryWithDistance(t, c.getCentralTrajectory());
    private double curSearchDist = QueryConstant.BASIC_BUFFER_DISTANCE;
    private double maxDistance = Double.MAX_VALUE;
    private final KNNQueryCondition knnCondition;
    private int stage;

    public KNNQuery(DataSetMeta dataSetMeta, KNNQueryCondition knnCondition) {
        super(dataSetMeta, new SpatialTemporalQueryCondition(
                new SpatialQueryCondition(SpatialQueryCondition.SpatialQueryType.INTERSECT),
                knnCondition.getTemporalQueryCondition()));
        this.knnCondition = knnCondition;
        this.stage = 0;
    }

    private boolean hasTimeConstrain() {
        return knnCondition.getTemporalQueryCondition() != null;
    }

    @Override
    public List<Trajectory> runPartitioned() throws IOException {
        setupTarget();
        switch (knnCondition.getKnnQueryType()) {
            case POINT:
                return runOnCase(
                        GET_GEOMETRY_WINDOW_CASE_POINT, NEW_TWD_CASE_POINT);
            case TRAJECTORY:
                return runOnCase(
                        GET_GEOMETRY_WINDOW_CASE_TRAJECTORY, NEW_TWD_CASE_TRAJECTORY);
            default:
                throw new UnsupportedOperationException();
        }
    }

    public List<Trajectory> runPartitionedPq() throws IOException {
        setupTarget();
        switch (knnCondition.getKnnQueryType()) {
            case POINT:
                return runPqOnCase(
                        GET_GEOMETRY_WINDOW_CASE_POINT, NEW_TWD_CASE_POINT);
            case TRAJECTORY:
                return runPqOnCase(
                        GET_GEOMETRY_WINDOW_CASE_TRAJECTORY, NEW_TWD_CASE_TRAJECTORY);
            default:
                throw new UnsupportedOperationException();
        }
    }

    @Override
    public List<Trajectory> runBySpark(SparkSession ss) throws IOException {
        setupTarget();
        List<Trajectory> trajectories;
        switch (knnCondition.getKnnQueryType()) {
            case POINT: {
                trajectories = runBySparkOnCase(
                        ss, GET_GEOMETRY_WINDOW_CASE_POINT, NEW_TWD_CASE_POINT);
                break;
            }
            case TRAJECTORY: {
                trajectories = runBySparkOnCase(
                        ss, GET_GEOMETRY_WINDOW_CASE_TRAJECTORY, NEW_TWD_CASE_TRAJECTORY);
                break;
            }
            default:
                throw new UnsupportedOperationException();
        }
        return trajectories;
    }

    public Trajectory[] knnRunBySparkCasePoint(SparkSession ss) throws IOException {
        setupTarget();
        int k = knnCondition.getK(), resultSearch = 0, searchNothing = 0;
        PriorityQueue<TrajectoryWithDistance> pq = new PriorityQueue<>(k, (twd1, twd2) -> {
            double dist1 = twd1.getDistance();
            double dist2 = twd2.getDistance();
            return Double.compare(dist2, dist1);
        });
        Set<RowKeyRange> set = new HashSet<>();
        Set<String> tidSet = new HashSet<>();
        JavaSparkContext sc = new JavaSparkContext(ss.sparkContext());
        long start = System.currentTimeMillis();
        while ((pq.size() < k && searchNothing < QueryConstant.MAX_QUERY_NOTHING_TIME) || (resultSearch != 0)) {
            // 首先更新时空查询条件
            condition.getSpatialQueryCondition()
                    .updateWindow(knnCondition.getCentralPoint().buffer(GeoUtil.getDegreeFromKm(curSearchDist)));
            List<RowKeyRange> rkRanges = getRanges(set);
            if (rkRanges.isEmpty()) {
                log.info("No more partitioned ranges.");
                break;
            }
            BasePoint centralPoint = knnCondition.getCentralPoint();
            String tableName = target.getTable().getName().getNameAsString();
            List<TrajectoryWithDistance> stageResult = sc.parallelize(rkRanges)
                    .groupBy(RowKeyRange::getShardKey)
                    .flatMap(pair -> {
                        List<RowKeyRange> ranges = new ArrayList<>();
                        for (RowKeyRange range : pair._2) {
                            ranges.add(range);
                        }
                        if (ranges.isEmpty()) {
                            return Collections.emptyIterator();
                        }
                        Table table = HBaseConnector.getConnection().getTable(TableName.valueOf(tableName));
                        return knnExecuteCasePoint(table, ranges, k, maxDistance, centralPoint).iterator();
                    })
                    .collect();
            resultSearch = addToHeap(k, tidSet, pq, stageResult);
            searchNothing = getSearchRadiusKM(k, resultSearch, searchNothing);
            if (!pq.isEmpty()) {
                maxDistance = pq.peek().getDistance();
            }
            ++stage;
            log.info("Start search radius {} at stage {}, got {} numbers count.",
                    curSearchDist, stage, resultSearch);
//            break;
        }
        Trajectory[] result = new Trajectory[pq.size()];
        int i = pq.size() - 1;
        while (!pq.isEmpty()) {
            result[i] = pq.poll().getTrajectory();
            --i;
        }
        System.out.println("KNN query finished, total time cost: "+ (System.currentTimeMillis() - start) + "ms");
        return result;
    }

    public Trajectory[] knnRunPartitionedBySparkCasePoint(SparkSession ss) throws IOException {
        setupTarget();
        int k = knnCondition.getK(), resultSearch = 0, searchNothing = 0;
        PriorityQueue<TrajectoryWithDistance> pq = new PriorityQueue<>(k, (twd1, twd2) -> {
            double dist1 = twd1.getDistance();
            double dist2 = twd2.getDistance();
            return Double.compare(dist2, dist1);
        });
        Set<RowKeyRange> set = new HashSet<>();
        Set<String> tidSet = new HashSet<>();
        JavaSparkContext sc = new JavaSparkContext(ss.sparkContext());
        long start = System.currentTimeMillis();
        while ((pq.size() < k && searchNothing < QueryConstant.MAX_QUERY_NOTHING_TIME) || (resultSearch != 0)) {
            // 首先更新时空查询条件
            condition.getSpatialQueryCondition()
                    .updateWindow(knnCondition.getCentralPoint().buffer(GeoUtil.getDegreeFromKm(curSearchDist)));
            List<RowKeyRange> rkRanges = getPartitionedRanges(set);
            if (rkRanges.isEmpty()) {
                log.info("No more partitioned ranges.");
                break;
            }
            BasePoint centralPoint = knnCondition.getCentralPoint();
            String tableName = target.getTable().getName().getNameAsString();
            List<TrajectoryWithDistance> stageResult = sc.parallelize(rkRanges)
                    .groupBy(RowKeyRange::getShardKey)
                    .flatMap(pair -> {
                        List<RowKeyRange> ranges = new ArrayList<>();
                        for (RowKeyRange range : pair._2) {
                            ranges.add(range);
                        }
                        if (ranges.isEmpty()) {
                            return Collections.emptyIterator();
                        }
                        Table table = HBaseConnector.getConnection().getTable(TableName.valueOf(tableName));
                        return knnExecuteCasePoint(table, ranges, k, maxDistance, centralPoint).iterator();
                    })
                    .collect();
            resultSearch = addToHeap(k, tidSet, pq, stageResult);
            searchNothing = getSearchRadiusKM(k, resultSearch, searchNothing);
            if (!pq.isEmpty()) {
                maxDistance = pq.peek().getDistance();
            }
            ++stage;
            log.info("Start search radius {} at stage {}, got {} numbers count.",
                    curSearchDist, stage, resultSearch);
        }
        Trajectory[] result = new Trajectory[pq.size()];
        int i = pq.size() - 1;
        while (!pq.isEmpty()) {
            result[i] = pq.poll().getTrajectory();
            --i;
        }
        System.out.println("KNN query finished, total time cost: "+ (System.currentTimeMillis() - start) + "ms");
        return result;
    }

    public Trajectory[] knnRunBySparkCaseTrajectory(SparkSession ss) throws IOException {
        setupTarget();
        int k = knnCondition.getK(), resultSearch = 0, searchNothing = 0;
        PriorityQueue<TrajectoryWithDistance> pq = new PriorityQueue<>(k, (twd1, twd2) -> {
            double dist1 = twd1.getDistance();
            double dist2 = twd2.getDistance();
            return Double.compare(dist2, dist1);
        });
        Set<RowKeyRange> set = new HashSet<>();
        Set<String> tidSet = new HashSet<>();
        JavaSparkContext sc = new JavaSparkContext(ss.sparkContext());
        long start = System.currentTimeMillis();
        while ((pq.size() < k && searchNothing < QueryConstant.MAX_QUERY_NOTHING_TIME) || (resultSearch != 0)) {
            // 首先更新时空查询条件
            condition.getSpatialQueryCondition()
                    .updateWindow(knnCondition.getCentralTrajectory().buffer(GeoUtil.getDegreeFromKm(curSearchDist)));
            List<RowKeyRange> rkRanges = getRanges(set);
            if (rkRanges.isEmpty()) {
                log.info("No more partitioned ranges.");
                break;
            }
            Trajectory centralTrajectory = knnCondition.getCentralTrajectory();
            String tableName = target.getTable().getName().getNameAsString();
            List<TrajectoryWithDistance> stageResult = sc.parallelize(rkRanges)
                    .groupBy(RowKeyRange::getShardKey)
                    .flatMap(pair -> {
                        List<RowKeyRange> ranges = new ArrayList<>();
                        for (RowKeyRange range : pair._2) {
                            ranges.add(range);
                        }
                        if (ranges.isEmpty()) {
                            return Collections.emptyIterator();
                        }
                        Table table = HBaseConnector.getConnection().getTable(TableName.valueOf(tableName));
                        return knnExecuteCaseTrajectory(
                                table, ranges, k, maxDistance, centralTrajectory).iterator();
                    })
                    .collect();
            resultSearch = addToHeap(k, tidSet, pq, stageResult);
            searchNothing = getSearchRadiusKM(k, resultSearch, searchNothing);
            if (!pq.isEmpty()) {
                maxDistance = pq.peek().getDistance();
            }
            ++stage;
            log.info("Start search radius {} at stage {}, got {} numbers count.",
                    curSearchDist, stage, resultSearch);
        }
        Trajectory[] result = new Trajectory[pq.size()];
        int i = pq.size() - 1;
        while (!pq.isEmpty()) {
            result[i] = pq.poll().getTrajectory();
            --i;
        }
        System.out.println("KNN query finished, total time cost: "+ (System.currentTimeMillis() - start) + "ms");
        return result;
    }

    public Trajectory[] knnRunPartitionedBySparkCaseTrajectory(SparkSession ss) throws IOException {
        setupTarget();
        int k = knnCondition.getK(), resultSearch = 0, searchNothing = 0;
        PriorityQueue<TrajectoryWithDistance> pq = new PriorityQueue<>(k, (twd1, twd2) -> {
            double dist1 = twd1.getDistance();
            double dist2 = twd2.getDistance();
            return Double.compare(dist2, dist1);
        });
        Set<RowKeyRange> set = new HashSet<>();
        Set<String> tidSet = new HashSet<>();
        JavaSparkContext sc = new JavaSparkContext(ss.sparkContext());
        long start = System.currentTimeMillis();
        while ((pq.size() < k && searchNothing < QueryConstant.MAX_QUERY_NOTHING_TIME) || (resultSearch != 0)) {
            // 首先更新时空查询条件
            condition.getSpatialQueryCondition()
                    .updateWindow(knnCondition.getCentralTrajectory().buffer(GeoUtil.getDegreeFromKm(curSearchDist)));
            List<RowKeyRange> rkRanges = getPartitionedRanges(set);
            if (rkRanges.isEmpty()) {
                log.info("No more partitioned ranges.");
                break;
            }
            Trajectory centralTrajectory = knnCondition.getCentralTrajectory();
            String tableName = target.getTable().getName().getNameAsString();
            List<TrajectoryWithDistance> stageResult = sc.parallelize(rkRanges)
                    .groupBy(RowKeyRange::getShardKey)
                    .flatMap(pair -> {
                        List<RowKeyRange> ranges = new ArrayList<>();
                        for (RowKeyRange range : pair._2) {
                            ranges.add(range);
                        }
                        if (ranges.isEmpty()) {
                            return Collections.emptyIterator();
                        }
                        Table table = HBaseConnector.getConnection().getTable(TableName.valueOf(tableName));
                        return knnExecuteCaseTrajectory(
                                table, ranges, k, maxDistance, centralTrajectory).iterator();
                    })
                    .collect();
            resultSearch = addToHeap(k, tidSet, pq, stageResult);
            searchNothing = getSearchRadiusKM(k, resultSearch, searchNothing);
            if (!pq.isEmpty()) {
                maxDistance = pq.peek().getDistance();
            }
            ++stage;
            log.info("Start search radius {} at stage {}, got {} numbers count.",
                    curSearchDist, stage, resultSearch);
        }
        Trajectory[] result = new Trajectory[pq.size()];
        int i = pq.size() - 1;
        while (!pq.isEmpty()) {
            result[i] = pq.poll().getTrajectory();
            --i;
        }
        System.out.println("KNN query finished, total time cost: "+ (System.currentTimeMillis() - start) + "ms");
        return result;
    }

    private List<RowKeyRange> getRanges(Set<RowKeyRange> set) {
        List<RowKeyRange> ranges = target
                .getIndexMeta()
                .getIndexStrategy()
                .getScanRanges(condition);
        ranges.removeAll(set);
        set.addAll(ranges);
        return ranges;
    }

    private List<RowKeyRange> getPartitionedRanges(Set<RowKeyRange> set) {
        List<RowKeyRange> ranges = target
                .getIndexMeta()
                .getIndexStrategy()
                .getPartitionedScanRanges(condition);
        ranges.removeAll(set);
        set.addAll(ranges);
        return ranges;
    }

    private List<Trajectory> getStageResultBySingle(Set<RowKeyRange> set) throws IOException {
        return execute(getPartitionedRanges(set));
    }

//    private List<Trajectory> getStageResultBySpark(Set<RowKeyRange> set) throws IOException {
//        return sc.parallelize(getPartitionedRanges(set))
//                .groupBy(RowKeyRange::getShardKey)
//                .flatMap(pair -> {
//                    List<RowKeyRange> rkRanges = new ArrayList<>();
//                    for (RowKeyRange rkRange : pair._2) {
//                        rkRanges.add(rkRange);
//                    }
//                    return execute(rkRanges).iterator();
//                })
//                .collect();
//    }

    public List<Trajectory> runOnCase(
            SerializableBiFunction<KNNQueryCondition, Double, Geometry> getGeometryWindow,
            SerializableBiFunction<KNNQueryCondition, Trajectory, TrajectoryWithDistance> newTrajectoryWithDistance)
            throws IOException {
        long start = System.currentTimeMillis();
        int k = knnCondition.getK(), resultSearch = 0, searchNothing = 0;
        PriorityQueue<TrajectoryWithDistance> pq = new PriorityQueue<>(k, (twd1, twd2) -> {
            double dist1 = twd1.getDistance();
            double dist2 = twd2.getDistance();
            
            return Double.compare(dist2, dist1);
        });
        Set<RowKeyRange> set = new HashSet<>();
        while ((pq.size() < k && searchNothing < QueryConstant.MAX_QUERY_NOTHING_TIME) || (resultSearch != 0)) {
            // 首先更新时空查询条件
            condition.getSpatialQueryCondition()
                    .updateWindow(getGeometryWindow
                            .apply(knnCondition, curSearchDist));
            List<RowKeyRange> rkRanges = getPartitionedRanges(set);
            if (rkRanges.isEmpty()) {
                log.info("No more partitioned ranges.");
                break;
            }
            List<Trajectory> stageResult = execute(rkRanges);
            stageResult.sort(Comparator.comparing(Trajectory::getTid));
            addToHeap(k, pq, stageResult, newTrajectoryWithDistance);
            resultSearch = stageResult.size();
            searchNothing = getSearchRadiusKM(k, resultSearch, searchNothing);
            if (!pq.isEmpty()) {
                maxDistance = pq.peek().getDistance();
            }
            ++stage;
            log.info("Start search radius {} at stage {}, got {} numbers count.",
                    curSearchDist, stage, resultSearch);
        }
        List<Trajectory> result = new ArrayList<>(pq.size());
        while (!pq.isEmpty()) {
            result.add(pq.poll().getTrajectory());
        }
        System.out.println("KNN query finished, total time cost: "+ (System.currentTimeMillis() - start) + "ms");
        return result;
    }

    public List<Trajectory> runPqOnCase(
            SerializableBiFunction<KNNQueryCondition, Double, Geometry> getGeometryWindow,
            SerializableBiFunction<KNNQueryCondition, Trajectory, TrajectoryWithDistance> newTrajectoryWithDistance)
            throws IOException {
        long start = System.currentTimeMillis();
        int k = knnCondition.getK(), resultSearch = 0, searchNothing = 0;
        PriorityQueue<TrajectoryWithDistance> pq = new PriorityQueue<>(k, (twd1, twd2) -> {
            double dist1 = twd1.getDistance();
            double dist2 = twd2.getDistance();
            
            return Double.compare(dist2, dist1);
        });
        Set<RowKeyRange> set = new HashSet<>();
        Set<String> tidSet = new HashSet<>();
        while ((pq.size() < k && searchNothing < QueryConstant.MAX_QUERY_NOTHING_TIME) || (resultSearch != 0)) {
            // 首先更新时空查询条件
            condition.getSpatialQueryCondition()
                    .updateWindow(getGeometryWindow
                            .apply(knnCondition, curSearchDist));
            List<RowKeyRange> rkRanges = getPartitionedRanges(set);
//            Map<Short, Integer> map = new HashMap<>();
//            for (RowKeyRange rkRange : rkRanges) {
//                map.put(rkRange.getShardKey(), map.getOrDefault(rkRange.getShardKey(), 0) + 1);
//            }
//            map.forEach((shardKey, count) -> System.out.println(shardKey + ": " + count));
            if (rkRanges.isEmpty()) {
                log.info("No more partitioned ranges.");
                break;
            }
//            List<Trajectory> stageResult = execute(rkRanges);
            PriorityQueue<TrajectoryWithDistance> stageResult = knnExecuteCasePoint(rkRanges);
//            addToHeap(k, pq, stageResult, newTrajectoryWithDistance);
//            if (stageResult.size() == k) {
//                pq = stageResult;
//                log.info("Get all results");
//                break;
//            }
            resultSearch = 0;
            while (!stageResult.isEmpty()) {
                TrajectoryWithDistance twd = stageResult.poll();
                System.out.println("dist: " + twd.getDistance());
                if (tidSet.contains(twd.getTrajectory().getTid())) {
                    System.out.println("duplicate tid: " + twd.getTrajectory().getTid());
                }
                if (twd.getDistance() < maxDistance && !tidSet.contains(twd.getTrajectory().getTid())) {
                    if (pq.size() < k) {
                        ++resultSearch;
                        tidSet.add(twd.getTrajectory().getTid());
                        pq.add(twd);
                    } else if (pq.peek().getDistance() > twd.getDistance()) {
                        System.out.println("poll: " + pq.peek().getDistance() + ", add: " + twd.getDistance());
                        ++resultSearch;
                        tidSet.add(twd.getTrajectory().getTid());
                        pq.poll();
                        pq.add(twd);
                    }
                }
            }
            searchNothing = getSearchRadiusKM(k, resultSearch, searchNothing);
            log.info("md before: " + maxDistance);
            if (!pq.isEmpty()) {
                maxDistance = pq.peek().getDistance();
            }
            log.info("md after: " + maxDistance);
//            System.out.println("size: " + pq2.size());
            ++stage;
            log.info("Start search radius {} at stage {}, got {} numbers count.",
                    curSearchDist, stage, resultSearch);
//            System.out.println((pq.size() < k && searchNothing < QueryConstant.MAX_QUERY_NOTHING_TIME) || (resultSearch != 0));
        }
        List<Trajectory> result = new ArrayList<>(pq.size());
        while (!pq.isEmpty()) {
            TrajectoryWithDistance twd = pq.poll();
            System.out.println("result dist: " + twd.getDistance());
            result.add(twd.getTrajectory());
        }
        System.out.println("KNN query finished, total time cost: "+ (System.currentTimeMillis() - start) + "ms");
        return result;
    }

    public List<Trajectory> runBySparkOnCase(SparkSession ss,
            SerializableBiFunction<KNNQueryCondition, Double, Geometry> getGeometryWindow,
            SerializableBiFunction<KNNQueryCondition, Trajectory, TrajectoryWithDistance> newTrajectoryWithDistance) {
        long start = System.currentTimeMillis();
        int k = knnCondition.getK(), resultSearch = 0, searchNothing = 0;
        PriorityQueue<TrajectoryWithDistance> pq = new PriorityQueue<>(k, (twd1, twd2) -> {
            double dist1 = twd1.getDistance();
            double dist2 = twd2.getDistance();
            
            return Double.compare(dist2, dist1);
        });
        Set<RowKeyRange> set = new HashSet<>();
        JavaSparkContext sc = new JavaSparkContext(ss.sparkContext());
        while ((pq.size() < k && searchNothing < QueryConstant.MAX_QUERY_NOTHING_TIME) || (resultSearch != 0)) {
            // 首先更新时空查询条件
            condition.getSpatialQueryCondition()
                    .updateWindow(getGeometryWindow
                            .apply(knnCondition, curSearchDist));
            List<RowKeyRange> rkRanges = getPartitionedRanges(set);
            if (rkRanges.isEmpty()) {
                log.info("No more partitioned ranges.");
                break;
            }
            String tableName = target.getTable().getName().getNameAsString();
            List<Trajectory> stageResult = new ArrayList<>(sc.parallelize(rkRanges)
                    .groupBy(RowKeyRange::getShardKey)
                    .flatMap(pair -> {
                        List<RowKeyRange> ranges = new ArrayList<>();
                        for (RowKeyRange range : pair._2) {
                            ranges.add(range);
                        }
                        if (ranges.isEmpty()) {
                            return Collections.emptyIterator();
                        }
                        Table table = HBaseConnector.getConnection().getTable(TableName.valueOf(tableName));
                        return execute(table, ranges).iterator();
                    })
                    .collect());
            stageResult.sort(Comparator.comparing(Trajectory::getTid));
            addToHeap(k, pq, stageResult, newTrajectoryWithDistance);
            resultSearch = stageResult.size();
            searchNothing = getSearchRadiusKM(k, resultSearch, searchNothing);
            if (!pq.isEmpty()) {
                maxDistance = pq.peek().getDistance();
            }
            ++stage;
            log.info("Start search radius {} at stage {}, got {} numbers count.",
                    curSearchDist, stage, resultSearch);
//            break;
        }
        List<Trajectory> result = new ArrayList<>(pq.size());
        while (!pq.isEmpty()) {
            result.add(pq.poll().getTrajectory());
        }
        System.out.println("KNN query finished, total time cost: "+ (System.currentTimeMillis() - start) + "ms");
        return result;
    }

    private void addToHeap(
            int k, PriorityQueue<TrajectoryWithDistance> pq, List<Trajectory> trajectories,
            SerializableBiFunction<KNNQueryCondition, Trajectory, TrajectoryWithDistance> newTrajectoryWithDistance) {
        Set<String> set = new HashSet<>();
        for (Trajectory t : trajectories) {
//            System.out.println("check: " + pq.size());
            if (!set.contains(t.getTid())) {
                set.add(t.getTid());
                TrajectoryWithDistance twd = newTrajectoryWithDistance.apply(knnCondition, t);
                if (pq.size() < k) {
                    pq.offer(twd);
                } else if (pq.peek().getDistance() > twd.getDistance()) {
                    pq.poll();
                    pq.offer(twd);
                }
            }
        }
    }

    private int addToHeap(
            int k, Set<String> tidSet, PriorityQueue<TrajectoryWithDistance> pq,
            List<TrajectoryWithDistance> trajectories) {
        int searchCount = 0;
        for (TrajectoryWithDistance twd : trajectories) {
//            System.out.println("check: " + pq.size());
            if (!tidSet.contains(twd.getTrajectory().getTid()) && twd.getDistance() < maxDistance) {
                if (pq.size() < k) {
                    tidSet.add(twd.getTrajectory().getTid());
                    pq.offer(twd);
                    ++searchCount;
                } else if (pq.peek().getDistance() > twd.getDistance()) {
                    tidSet.add(twd.getTrajectory().getTid());
                    pq.poll();
                    pq.offer(twd);
                    ++searchCount;
                }
            }
        }
        return searchCount;
    }

    private int getSearchRadiusKM(int k, int resultSearch, int searchNothing) {
//        if (resultSearch > 0) {
//            double temp = k / (double) resultSearch;
//            if (temp <= 10.0) {
//                curSearchDist *= SQRT_2;
//            } else {
//                curSearchDist *= Math.sqrt(temp);
//            }
//        } else {
//            curSearchDist *= SQRT_2;
//            ++searchNothing;
//        }
//        if (resultSearch == 0) {
//            ++searchNothing;
//        }
        curSearchDist *= SQRT_2;
        if (resultSearch == 0) {
            ++searchNothing;
        }
        return searchNothing;
    }

    @Override
    protected IndexMeta<SpatialTemporalQueryCondition> findBestIndex() {
        Map<IndexType, List<IndexMeta>> map = dataSetMeta.getAvailableIndexes();
        // case 1: 无时间约束，找XZ2索引
        if (!hasTimeConstrain()) {
            if (map.containsKey(IndexType.XZ2)) {
                return IndexMeta.getBestIndexMeta(map.get(IndexType.XZ2));
            }
        }
        // case 2: 有时间约束，找XZ2T索引或TXZ2索引
        else {
            if (map.containsKey(IndexType.XZ2T)) {
                return IndexMeta.getBestIndexMeta(map.get(IndexType.XZ2T));
            }
            if (map.containsKey(IndexType.TXZ2)) {
                return IndexMeta.getBestIndexMeta(map.get(IndexType.TXZ2));
            }
            if (map.containsKey(IndexType.JST)) {
                return IndexMeta.getBestIndexMeta(map.get(IndexType.JST));
            }
        }
        return null;
    }

    @Override
    protected String getQueryInfo() {
        return knnCondition.getConditionInfo();
    }

    private QueryCondition.QueryRequest buildQueryRequestCasePointHasTimeConstrain(
            QueryCondition.QueryRequest.Builder qrBuilder,
            QueryCondition.KNNQueryRequest.Builder kqrBuilder,
            QueryCondition.TemporalQueryWindow tqw) throws IOException {
        return qrBuilder
                .setKnn(kqrBuilder
                        .setPoint(ByteString.copyFrom(knnCondition.getPointBytes()))
                        .setTemporalQueryWindow(tqw)
                        .build())
                .build();
    }

    private QueryCondition.QueryRequest buildQueryRequestCasePointHasNotTimeConstrain(
            QueryCondition.QueryRequest.Builder qrBuilder,
            QueryCondition.KNNQueryRequest.Builder kqrBuilder) throws IOException {
        return qrBuilder
                .setKnn(kqrBuilder
                        .setPoint(ByteString.copyFrom(knnCondition.getPointBytes()))
                        .build())
                .build();
    }

    private QueryCondition.QueryRequest buildQueryRequestCaseTrajectoryHasTimeConstrain(
            QueryCondition.QueryRequest.Builder qrBuilder,
            QueryCondition.KNNQueryRequest.Builder kqrBuilder,
            QueryCondition.TemporalQueryWindow tqw) throws IOException {
        return qrBuilder
                .setKnn(kqrBuilder
                        .setTrajectory(ByteString.copyFrom(knnCondition.getTrajectoryBytes()))
                        .setTemporalQueryWindow(tqw)
                        .build())
                .build();
    }

    private QueryCondition.QueryRequest buildQueryRequestCaseTrajectoryHasNotTimeConstrain(
            QueryCondition.QueryRequest.Builder qrBuilder,
            QueryCondition.KNNQueryRequest.Builder kqrBuilder) throws IOException {
        return qrBuilder
                .setKnn(kqrBuilder
                        .setTrajectory(ByteString.copyFrom(knnCondition.getTrajectoryBytes()))
                        .build())
                .build();
    }

    private List<Trajectory> execute(Table table, List<RowKeyRange> rkRanges) throws IOException {
        List<QueryCondition.Range> ranges = rowKeyRangeToProtoRange(rkRanges);
        QueryCondition.TemporalQueryWindow tqw =
                QueryProtoBuilder.buildProtoTemporalWindow(knnCondition.getTemporalQueryCondition());
        QueryCondition.QueryRequest.Builder qrBuilder = QueryCondition.QueryRequest
                .newBuilder()
                .setQueryOperation(QueryCondition.QueryMethod.KNN)
                .addAllRange(ranges);
        QueryCondition.KNNQueryRequest.Builder kqrBuilder = QueryCondition.KNNQueryRequest
                .newBuilder()
                .setK(knnCondition.getK())
                .setDistance(GeoUtil.getDegreeFromKm(maxDistance));
        switch (knnCondition.getKnnQueryType()) {
            case POINT: {
                QueryCondition.QueryRequest knnQueryRequest;
                if (hasTimeConstrain()) {
                    knnQueryRequest = buildQueryRequestCasePointHasTimeConstrain(qrBuilder, kqrBuilder, tqw);
                } else {
                    knnQueryRequest = buildQueryRequestCasePointHasNotTimeConstrain(qrBuilder, kqrBuilder);
                }
                return STCoprocessorQuery.execute(table, knnQueryRequest);
            }
            case TRAJECTORY: {
                QueryCondition.QueryRequest knnQueryRequest;
                if (hasTimeConstrain()) {
                    knnQueryRequest = buildQueryRequestCaseTrajectoryHasTimeConstrain(qrBuilder, kqrBuilder, tqw);
                } else {
                    knnQueryRequest = buildQueryRequestCaseTrajectoryHasNotTimeConstrain(qrBuilder, kqrBuilder);
                }
                return STCoprocessorQuery.execute(table, knnQueryRequest);
            }
            default:
                throw new UnsupportedEncodingException();
        }
    }

    @Override
    protected List<Trajectory> execute(List<RowKeyRange> rkRanges) throws IOException {
        return execute(target.getTable(), rkRanges);
    }

    protected PriorityQueue<TrajectoryWithDistance> knnExecuteCasePoint(List<RowKeyRange> rkRanges)
            throws IOException {
        return knnExecuteCasePoint(
                target.getTable(), rkRanges, knnCondition.getK(), maxDistance, knnCondition.getCentralPoint());
    }

    protected PriorityQueue<TrajectoryWithDistance> knnExecuteCasePoint(
            Table table, List<RowKeyRange> rkRanges, int k, double maxDistance,
            BasePoint centralPoint)
            throws IOException {
        List<QueryCondition.Range> ranges = rowKeyRangeToProtoRange(rkRanges);
        QueryCondition.TemporalQueryWindow tqw =
                QueryProtoBuilder.buildProtoTemporalWindow(knnCondition.getTemporalQueryCondition());
        QueryCondition.QueryRequest.Builder qrBuilder = QueryCondition.QueryRequest
                .newBuilder()
                .setQueryOperation(QueryCondition.QueryMethod.KNN)
                .addAllRange(ranges);
        QueryCondition.KNNQueryRequest.Builder kqrBuilder = QueryCondition.KNNQueryRequest
                .newBuilder()
                .setK(k)
                .setDistance(GeoUtil.getDegreeFromKm(maxDistance));
        QueryCondition.QueryRequest knnQueryRequest;
        if (hasTimeConstrain()) {
            knnQueryRequest = buildQueryRequestCasePointHasTimeConstrain(qrBuilder, kqrBuilder, tqw);
        } else {
            knnQueryRequest = buildQueryRequestCasePointHasNotTimeConstrain(qrBuilder, kqrBuilder);
        }
        return STCoprocessorQuery.knnExecuteCasePoint(table, knnQueryRequest, k, maxDistance, centralPoint);
    }

    protected PriorityQueue<TrajectoryWithDistance> knnExecuteCaseTrajectory(
            Table table, List<RowKeyRange> rkRanges, int k, double maxDistance,
            Trajectory centralTrajectory)
            throws IOException {
        List<QueryCondition.Range> ranges = rowKeyRangeToProtoRange(rkRanges);
        QueryCondition.TemporalQueryWindow tqw =
                QueryProtoBuilder.buildProtoTemporalWindow(knnCondition.getTemporalQueryCondition());
        QueryCondition.QueryRequest.Builder qrBuilder = QueryCondition.QueryRequest
                .newBuilder()
                .setQueryOperation(QueryCondition.QueryMethod.KNN)
                .addAllRange(ranges);
        QueryCondition.KNNQueryRequest.Builder kqrBuilder = QueryCondition.KNNQueryRequest
                .newBuilder()
                .setK(k)
                .setDistance(GeoUtil.getDegreeFromKm(maxDistance));
        QueryCondition.QueryRequest knnQueryRequest;
        if (hasTimeConstrain()) {
            knnQueryRequest = buildQueryRequestCaseTrajectoryHasTimeConstrain(qrBuilder, kqrBuilder, tqw);
        } else {
            knnQueryRequest = buildQueryRequestCaseTrajectoryHasNotTimeConstrain(qrBuilder, kqrBuilder);
        }
        return STCoprocessorQuery.knnExecuteCaseTrajectory(
                table, knnQueryRequest, k, maxDistance, centralTrajectory);
    }
}
