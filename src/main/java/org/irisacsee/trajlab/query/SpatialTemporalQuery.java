package org.irisacsee.trajlab.query;

import org.irisacsee.trajlab.index.IndexType;
import org.irisacsee.trajlab.index.type.RowKeyRange;
import org.irisacsee.trajlab.meta.DataSetMeta;
import org.irisacsee.trajlab.meta.IndexMeta;
import org.irisacsee.trajlab.model.Trajectory;
import org.irisacsee.trajlab.query.condition.SpatialQueryCondition;
import org.irisacsee.trajlab.query.condition.SpatialTemporalQueryCondition;
import org.irisacsee.trajlab.query.condition.TemporalQueryCondition;
import org.irisacsee.trajlab.query.coprocessor.QueryProtoBuilder;
import org.irisacsee.trajlab.query.coprocessor.STCoprocessorQuery;
import org.irisacsee.trajlab.query.coprocessor.autogenerated.QueryCondition;

import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * 时空查询
 *
 * @author irisacsee
 * @since 2024/11/22
 */
public class SpatialTemporalQuery extends AbstractQuery<SpatialTemporalQueryCondition> {
    public SpatialTemporalQuery(DataSetMeta dataSet, SpatialTemporalQueryCondition condition) {
        super(dataSet, condition);
    }

    @Override
    protected IndexMeta findBestIndex() {
        Map<IndexType, List<IndexMeta>> map = dataSetMeta.getAvailableIndexes();
        // find a st index
        List<IndexMeta> indexList = null;
        if (map.containsKey(IndexType.TXZ2)) {
            indexList = map.get(IndexType.TXZ2);
        } else if (map.containsKey(IndexType.XZ2T)) {
            indexList = map.get(IndexType.XZ2T);
        }
        if (indexList != null) {
            return IndexMeta.getBestIndexMeta(indexList);
        }
        // TODO: 直接抛异常，禁止全表扫描
        // no st index so we will do a full table scan, we select a main index.
        return dataSetMeta.getMainIndexMeta();
    }

    @Override
    protected String getQueryInfo() {
        return condition.getConditionInfo();
    }

    @Override
    protected List<Trajectory> execute(List<RowKeyRange> rkRanges) throws IOException {
        List<QueryCondition.Range> ranges = rowKeyRangeToProtoRange(rkRanges);
        SpatialQueryCondition sqc = condition.getSpatialQueryCondition();
        TemporalQueryCondition tqc = condition.getTemporalQueryCondition();
        List<QueryCondition.TemporalQueryWindow> tqw = QueryProtoBuilder.buildProtoTemporalWindows(tqc);
        QueryCondition.QueryRequest stQueryRequest = QueryCondition.QueryRequest.newBuilder()
                .addAllRange(ranges)
                .setSt(QueryCondition.STQueryRequest.newBuilder()
                        .setSpatialQueryType(sqc.getQueryType() == SpatialQueryCondition.SpatialQueryType.CONTAIN
                                ? QueryCondition.QueryType.CONTAIN
                                : QueryCondition.QueryType.INTERSECT)
                        .setSpatialQueryWindow(QueryCondition.SpatialQueryWindow.newBuilder()
                                .setWkt(sqc.getQueryWindowWKT()))
                        .setTemporalQueryType(tqc.getQueryType() == TemporalQueryCondition.TemporalQueryType.CONTAIN
                                ? QueryCondition.QueryType.CONTAIN
                                : QueryCondition.QueryType.INTERSECT)
                        .setTemporalQueryWindows(QueryCondition.TemporalQueryWindows.newBuilder()
                                .addAllTemporalQueryWindow(tqw)
                                .build())
                        .setFilterBeforeLookFullRow(true)
                        .build())
                .setQueryOperation(QueryCondition.QueryMethod.ST)
                .build();
        return STCoprocessorQuery.execute(target.getTable(), stQueryRequest);
    }
}
