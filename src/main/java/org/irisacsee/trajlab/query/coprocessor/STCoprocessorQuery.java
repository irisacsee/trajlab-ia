package org.irisacsee.trajlab.query.coprocessor;

import org.apache.hadoop.hbase.client.Table;
import org.apache.hadoop.hbase.client.coprocessor.Batch;
import org.apache.hadoop.hbase.ipc.BlockingRpcCallback;
import org.apache.hadoop.hbase.ipc.ServerRpcController;
import org.irisacsee.trajlab.model.BasePoint;
import org.irisacsee.trajlab.model.Trajectory;
import org.irisacsee.trajlab.model.TrajectoryMapper;
import org.irisacsee.trajlab.model.TrajectoryWithDistance;
import org.irisacsee.trajlab.query.condition.KNNQueryCondition;
import org.irisacsee.trajlab.query.coprocessor.autogenerated.QueryCondition;
import org.irisacsee.trajlab.store.IndexTable;
import org.irisacsee.trajlab.util.SerializableBiFunction;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;

/**
 * 协处理器查询
 *
 * @author irisacsee
 * @since 2024/11/22
 */
public class STCoprocessorQuery {
    public static List<Trajectory> execute(
            Table table, QueryCondition.QueryRequest request) throws IOException {
        List<QueryCondition.Range> ranges = request.getRangeList();
        Map<byte[], List<QueryCondition.TrajectoryResult>> coprocessorResult = null;
        try {
            coprocessorResult = table.coprocessorService(
                    QueryCondition.QueryService.class,
                    ranges.get(0).getStart().toByteArray(),
                    ranges.get(ranges.size() - 1).getEnd().toByteArray(),
                    queryService -> {
                        BlockingRpcCallback<QueryCondition.QueryResponse> rpcCallback = new BlockingRpcCallback<>();
                        queryService.query(new ServerRpcController(), request, rpcCallback);
                        QueryCondition.QueryResponse response = rpcCallback.get();
                        return response.getListList();
                    });
        } catch (Throwable e) {
            e.printStackTrace();
        }
        List<Trajectory> result = new ArrayList<>();
        for (List<QueryCondition.TrajectoryResult> trajectoryResultList : coprocessorResult.values()) {
            for (QueryCondition.TrajectoryResult tr : trajectoryResultList) {
                Trajectory trajectory = TrajectoryMapper.protoResultToTrajectory(tr);
                result.add(trajectory);
            }
        }
        return result;
    }

    public static PriorityQueue<TrajectoryWithDistance> knnExecuteCasePoint(
            Table table, QueryCondition.QueryRequest request, int k, double maxDistance,
            BasePoint centralPoint) throws IOException {
        List<QueryCondition.Range> ranges = request.getRangeList();
        Map<byte[], List<QueryCondition.TrajectoryResult>> coprocessorResult = null;
        try {
            coprocessorResult = table.coprocessorService(
                    QueryCondition.QueryService.class,
                    ranges.get(0).getStart().toByteArray(),
                    ranges.get(ranges.size() - 1).getEnd().toByteArray(),
                    queryService -> {
                        BlockingRpcCallback<QueryCondition.QueryResponse> rpcCallback = new BlockingRpcCallback<>();
                        queryService.query(new ServerRpcController(), request, rpcCallback);
                        QueryCondition.QueryResponse response = rpcCallback.get();
                        return response.getListList();
                    });
        } catch (Throwable e) {
            e.printStackTrace();
        }
        PriorityQueue<TrajectoryWithDistance> pq = new PriorityQueue<>(k, (twd1, twd2) -> {
            double dist1 = twd1.getDistance();
            double dist2 = twd2.getDistance();
            return Double.compare(dist2, dist1);
        });
        Set<String> tidSet = new HashSet<>();
        for (List<QueryCondition.TrajectoryResult> trajectoryResultList : coprocessorResult.values()) {
            for (QueryCondition.TrajectoryResult tr : trajectoryResultList) {
                Trajectory trajectory = TrajectoryMapper.protoResultToTrajectory(tr);
                if (!tidSet.contains(trajectory.getTid())) {
                    tidSet.add(trajectory.getTid());
                    TrajectoryWithDistance twd = new TrajectoryWithDistance(
                            TrajectoryMapper.protoResultToTrajectory(tr), centralPoint);
                    if (twd.getDistance() < maxDistance) {
                        if (pq.size() < k) {
                            pq.offer(twd);
                        } else if (pq.peek().getDistance() > twd.getDistance()) {
                            pq.poll();
                            pq.offer(twd);
                        }
                    }
                }
            }
        }
        return pq;
    }

    public static PriorityQueue<TrajectoryWithDistance> knnExecuteCaseTrajectory(
            Table table, QueryCondition.QueryRequest request, int k, double maxDistance,
            Trajectory centralTrajectory) throws IOException {
        List<QueryCondition.Range> ranges = request.getRangeList();
        Map<byte[], List<QueryCondition.TrajectoryResult>> coprocessorResult = null;
        try {
            coprocessorResult = table.coprocessorService(
                    QueryCondition.QueryService.class,
                    ranges.get(0).getStart().toByteArray(),
                    ranges.get(ranges.size() - 1).getEnd().toByteArray(),
                    queryService -> {
                        BlockingRpcCallback<QueryCondition.QueryResponse> rpcCallback = new BlockingRpcCallback<>();
                        queryService.query(new ServerRpcController(), request, rpcCallback);
                        QueryCondition.QueryResponse response = rpcCallback.get();
                        return response.getListList();
                    });
        } catch (Throwable e) {
            e.printStackTrace();
        }
        PriorityQueue<TrajectoryWithDistance> pq = new PriorityQueue<>(k, (twd1, twd2) -> {
            double dist1 = twd1.getDistance();
            double dist2 = twd2.getDistance();
            return Double.compare(dist2, dist1);
        });
        Set<String> tidSet = new HashSet<>();
        for (List<QueryCondition.TrajectoryResult> trajectoryResultList : coprocessorResult.values()) {
            for (QueryCondition.TrajectoryResult tr : trajectoryResultList) {
                Trajectory trajectory = TrajectoryMapper.protoResultToTrajectory(tr);
                if (!tidSet.contains(trajectory.getTid())) {
                    tidSet.add(trajectory.getTid());
                    TrajectoryWithDistance twd = new TrajectoryWithDistance(
                            TrajectoryMapper.protoResultToTrajectory(tr), centralTrajectory);
                    if (twd.getDistance() < maxDistance) {
                        if (pq.size() < k) {
                            pq.offer(twd);
                        } else if (pq.peek().getDistance() > twd.getDistance()) {
                            pq.poll();
                            pq.offer(twd);
                        }
                    }
                }
            }
        }
        return pq;
    }
}
