package org.irisacsee.trajlab.model;

import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONException;
import com.alibaba.fastjson.JSONObject;
import org.apache.hadoop.hbase.Cell;
import org.apache.hadoop.hbase.KeyValue;
import org.apache.hadoop.hbase.client.Put;
import org.apache.hadoop.hbase.client.RegionLocator;
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.client.Table;
import org.apache.hadoop.hbase.io.ImmutableBytesWritable;
import org.apache.hadoop.hbase.mapreduce.HFileOutputFormat2;
import org.apache.hadoop.hbase.util.Bytes;
import org.apache.hadoop.mapreduce.Job;
import org.irisacsee.trajlab.constant.DBConstant;
import org.irisacsee.trajlab.index.IndexStrategy;
import org.irisacsee.trajlab.index.type.KeyFamilyQualifier;
import org.irisacsee.trajlab.index.type.TimeLine;
import org.irisacsee.trajlab.query.coprocessor.autogenerated.QueryCondition;
import org.irisacsee.trajlab.util.SerializableFunction;
import org.irisacsee.trajlab.serializer.ObjectSerializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import scala.Tuple2;

import java.io.IOException;
import java.io.Serializable;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.irisacsee.trajlab.model.Trajectory.Schema.*;

/**
 * 轨迹数据转换类
 *
 * @author irisacsee
 * @since 2024/11/19
 */
public class TrajectoryMapper {
    private static final Logger LOGGER = LoggerFactory.getLogger(TrajectoryMapper.class);
    private static final String[] MAIN_INDEX_DATA_FRAME = new String[]{
            TRAJECTORY_ID, OBJECT_ID, TRAJ_POINTS, MBR, START_TIME, END_TIME, START_POSITION,
            END_POSITION, POINT_NUMBER, SPEED, LENGTH, EXT_VALUES};
    private static final String[] SECONDARY_INDEX_DATA_FRAME = new String[]{PTR};

    /**
     * 添加轨迹基本信息
     *
     * @param trajectory 轨迹对象
     * @return put对象
     * @throws IOException 抛出IO异常
     */
    private static Put addBasicTrajectoryInfo(Trajectory trajectory, IndexStrategy<?> indexStrategy) throws IOException {
        Put put = new Put(indexStrategy.index(trajectory));
        if (!trajectory.isUpdateFeatures()) {
            TrajectoryFeatures trajectoryFeatures = trajectory.getTrajectoryFeatures();
            put.addColumn(DBConstant.COLUMN_FAMILY, DBConstant.MBR_QUALIFIER,
                    ObjectSerializer.serializeObject(trajectoryFeatures.getMbr()));
            put.addColumn(DBConstant.COLUMN_FAMILY, DBConstant.START_POINT_QUALIFIER,
                    ObjectSerializer.serializeObject(trajectoryFeatures.getStartPoint()));
            put.addColumn(DBConstant.COLUMN_FAMILY, DBConstant.END_POINT_QUALIFIER,
                    ObjectSerializer.serializeObject(trajectoryFeatures.getEndPoint()));
            put.addColumn(DBConstant.COLUMN_FAMILY, DBConstant.START_TIME_QUALIFIER,
                    ObjectSerializer.serializeObject(trajectoryFeatures.getStartTime()));
            put.addColumn(DBConstant.COLUMN_FAMILY, DBConstant.END_TIME_QUALIFIER,
                    ObjectSerializer.serializeObject(trajectoryFeatures.getEndTime()));
            put.addColumn(DBConstant.COLUMN_FAMILY, DBConstant.POINT_NUMBER_QUALIFIER,
                    ObjectSerializer.serializeObject(trajectoryFeatures.getPointNum()));
            put.addColumn(DBConstant.COLUMN_FAMILY, DBConstant.SPEED_QUALIFIER,
                    ObjectSerializer.serializeObject(trajectoryFeatures.getSpeed()));
            put.addColumn(DBConstant.COLUMN_FAMILY, DBConstant.LENGTH_QUALIFIER,
                    ObjectSerializer.serializeObject(trajectoryFeatures.getLen()));
        }
        if (trajectory.getExtendedValues() != null) {
            put.addColumn(DBConstant.COLUMN_FAMILY, DBConstant.EXT_VALUES_QUALIFIER,
                    ObjectSerializer.serializeObject((Serializable) trajectory.getExtendedValues()));
        }
        return put;
    }

    /**
     * 将轨迹转换为主索引put对象
     *
     * @param trajectory 轨迹对象
     * @return put对象
     */
    public static Put mapTrajectoryToMainIndexPut(Trajectory trajectory, IndexStrategy<?> indexStrategy)
            throws IOException {
        Put put = addBasicTrajectoryInfo(trajectory, indexStrategy);
        put.addColumn(DBConstant.COLUMN_FAMILY, DBConstant.OBJECT_ID_QUALIFIER,
                ObjectSerializer.serializeObject(trajectory.getOid()));
        put.addColumn(DBConstant.COLUMN_FAMILY, DBConstant.TRAJECTORY_ID_QUALIFIER,
                ObjectSerializer.serializeObject(trajectory.getTid()));
        put.addColumn(DBConstant.COLUMN_FAMILY, DBConstant.TRAJ_POINTS_QUALIFIER,
                ObjectSerializer.serializeList(trajectory.getPoints(), TrajectoryPoint.class));
        return put;
    }

    /**
     * 将轨迹转换为辅助索引put对象
     *
     * @param trajectory 轨迹对象
     * @param ptr        主索引rowKey
     * @return put对象
     */
    public static Put mapTrajectoryToSecondrayIndexPut(
            Trajectory trajectory, IndexStrategy<?> indexStrategy, byte[] ptr)
            throws IOException {
        Put put = addBasicTrajectoryInfo(trajectory, indexStrategy);
        put.addColumn(DBConstant.COLUMN_FAMILY, DBConstant.PTR_QUALIFIER, ptr);
        return put;
    }

    public static Trajectory getTrajectoryFromResult(Result result) throws IOException {
        byte[] TrajectoryPointByteArray = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.TRAJ_POINTS_QUALIFIER);
        byte[] objectID = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.OBJECT_ID_QUALIFIER);
        byte[] tID = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.TRAJECTORY_ID_QUALIFIER);
        return bytesToTrajectory(TrajectoryPointByteArray, objectID, tID);
    }

    public static Trajectory getAllTrajectoryFromResult(Result result) throws IOException {
        byte[] TrajectoryPointByteArray = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.TRAJ_POINTS_QUALIFIER);
        byte[] objectID = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.OBJECT_ID_QUALIFIER);
        byte[] tID = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.TRAJECTORY_ID_QUALIFIER);
        Trajectory trajectory = bytesToTrajectory(TrajectoryPointByteArray, objectID, tID);
        addFeaturesToTrajectory(trajectory, result);
        return trajectory;
    }

    public static void addFeaturesToTrajectory(Trajectory trajectory, Result result) {
        if (result.containsColumn(DBConstant.COLUMN_FAMILY, DBConstant.START_TIME_QUALIFIER)) {
            TrajectoryFeatures trajectoryFeaturesFromResult = getTrajectoryFeaturesFromResult(result);
            trajectory.setFeatures(trajectoryFeaturesFromResult);
        }
        if (result.containsColumn(DBConstant.COLUMN_FAMILY, DBConstant.EXT_VALUES_QUALIFIER)) {
            byte[] extendValue = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.EXT_VALUES_QUALIFIER);
            HashMap<String, Object> extendValueStr =
                    (HashMap<String, Object>) ObjectSerializer.deserializeObject(extendValue, HashMap.class);
            trajectory.setExtendedValues(extendValueStr);
        }
    }

    private static TrajectoryFeatures getTrajectoryFeaturesFromResult(Result result) {
        byte[] startTime = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.START_TIME_QUALIFIER);
        byte[] endTime = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.END_TIME_QUALIFIER);
        byte[] startPoint = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.START_POINT_QUALIFIER);
        byte[] endPoint = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.END_POINT_QUALIFIER);
        byte[] pointNum = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.POINT_NUMBER_QUALIFIER);
        byte[] mbr = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.MBR_QUALIFIER);
        byte[] speed = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.SPEED_QUALIFIER);
        byte[] length = result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.LENGTH_QUALIFIER);
        return bytesToTrajectoryFeatures(startTime, endTime, startPoint, endPoint,
                pointNum, mbr, speed, length);
    }

    private static TrajectoryFeatures bytesToTrajectoryFeatures(
            byte[] startTime, byte[] endTime, byte[] startPoint, byte[] endPoint,
            byte[] pointNum, byte[] mbr, byte[] speed, byte[] length) {
        ZonedDateTime startTimeStr =
                (ZonedDateTime) ObjectSerializer.deserializeObject(startTime, ZonedDateTime.class);
        ZonedDateTime endTimeStr =
                (ZonedDateTime) ObjectSerializer.deserializeObject(endTime, ZonedDateTime.class);
        TrajectoryPoint startPointStr = (TrajectoryPoint) ObjectSerializer.deserializeObject(startPoint,
                TrajectoryPoint.class);
        TrajectoryPoint endPointStr = (TrajectoryPoint) ObjectSerializer.deserializeObject(endPoint,
                TrajectoryPoint.class);
        Integer pointNumStr = (Integer) ObjectSerializer.deserializeObject(pointNum, Integer.class);
        MinimumBoundingBox mbrStr =
                (MinimumBoundingBox) ObjectSerializer.deserializeObject(mbr, MinimumBoundingBox.class);
        Double speedStr = (Double) ObjectSerializer.deserializeObject(speed, Double.class);
        Double lengthStr = (Double) ObjectSerializer.deserializeObject(length, Double.class);
        return new TrajectoryFeatures(
                startTimeStr, endTimeStr, startPointStr, endPointStr, pointNumStr, mbrStr, speedStr, lengthStr);
    }

    private static Trajectory bytesToTrajectory(byte[] TrajectoryPointByteArray, byte[] objectID,
                                                byte[] tID) throws IOException {
        List<TrajectoryPoint> TrajectoryPointList = ObjectSerializer.deserializeList(TrajectoryPointByteArray,
                TrajectoryPoint.class);
        String objectStr = (String) ObjectSerializer.deserializeObject(objectID, String.class);
        String tidStr = (String) ObjectSerializer.deserializeObject(tID, String.class);
        return new Trajectory(tidStr, objectStr, TrajectoryPointList);
    }

    /**
     * 获取将put转换为keyValue的函数
     *
     * @param isMainIndex 是否是主索引
     * @return 将put转换为keyValue的函数
     */
    public static SerializableFunction<Put, List<Tuple2<KeyFamilyQualifier, KeyValue>>> getMapPutToKeyValue(
            boolean isMainIndex) {
        return isMainIndex
                ? x -> mapPutToKeyValue(x, MAIN_INDEX_DATA_FRAME)
                : x -> mapPutToKeyValue(x, SECONDARY_INDEX_DATA_FRAME);
    }

    /**
     * 将put转换为keyValue
     *
     * @param put       put对象
     * @param dataFrame 表的列名
     * @return keyValue列表
     */
    public static List<Tuple2<KeyFamilyQualifier, KeyValue>> mapPutToKeyValue(Put put, String[] dataFrame) {
        List<Tuple2<KeyFamilyQualifier, KeyValue>> keyValueList = new ArrayList<>();
        for (String frame : dataFrame) {
            if (put.has(DBConstant.COLUMN_FAMILY, Bytes.toBytes(frame))) {
                List<Cell> cells = put.get(DBConstant.COLUMN_FAMILY, Bytes.toBytes(frame));
                Result result = Result.create(cells);
                byte[] quaFilterValue = result.getValue(DBConstant.COLUMN_FAMILY, Bytes.toBytes(frame));
                KeyValue keyValue = new KeyValue(put.getRow(), DBConstant.COLUMN_FAMILY, Bytes.toBytes(frame),
                        quaFilterValue);
                KeyFamilyQualifier keyFamilyQualifier = new KeyFamilyQualifier(result.getRow(), DBConstant.COLUMN_FAMILY,
                        Bytes.toBytes(frame));
                keyValueList.add(new Tuple2<>(keyFamilyQualifier, keyValue));
            }
        }
        return keyValueList;
    }

    /**
     * 配置HFile的输出格式，用于bulkLoad
     *
     * @param table   需要bulkLoad的表
     * @param locator 需要bulkLoad的表的regionLocator
     * @param job     MapReduce的job对象
     * @throws IOException 抛出IO异常
     */
    public static void configureHFilesOnHDFS(Table table, RegionLocator locator, Job job)
            throws IOException {
        job.setMapOutputKeyClass(ImmutableBytesWritable.class);
        job.setMapOutputValueClass(KeyValue.class);
        HFileOutputFormat2.configureIncrementalLoad(job, table, locator);
    }

    /**
     * 将proto格式的轨迹结果转换为轨迹对象
     *
     * @param tr proto格式的轨迹结果
     * @return 轨迹对象
     * @throws IOException 抛出IO异常
     */
    public static Trajectory protoResultToTrajectory(QueryCondition.TrajectoryResult tr)
            throws IOException {
        byte[] TrajectoryPointByteArray = tr.getTrajPointList().toByteArray();
        byte[] objectID = tr.getObjectId().toByteArray();
        byte[] tID = tr.getTid().toByteArray();
        List<TrajectoryPoint> TrajectoryPointList = ObjectSerializer.deserializeList(TrajectoryPointByteArray,
                TrajectoryPoint.class);
        String objectStr = (String) ObjectSerializer.deserializeObject(objectID, String.class);
        String tidStr = (String) ObjectSerializer.deserializeObject(tID, String.class);
        return new Trajectory(tidStr, objectStr, TrajectoryPointList);
    }

    /**
     * 将<b>主索引表</b>中的行转换为轨迹对象
     *
     * @param result 主索引表的行，包含了轨迹的全部信息
     * @return 该行存储的轨迹对象
     */
    public static Trajectory mainRowToTrajectory(Result result) throws IOException {
        Trajectory trajectory = new Trajectory();
        trajectory.setTid((String) ObjectSerializer.deserializeObject(
                result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.TRAJECTORY_ID_QUALIFIER), String.class));
        trajectory.setOid((String) ObjectSerializer.deserializeObject(
                result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.OBJECT_ID_QUALIFIER), String.class));
        trajectory.setPoints(ObjectSerializer.deserializeList(
                result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.TRAJ_POINTS_QUALIFIER), TrajectoryPoint.class));
        return trajectory;
    }

    public static Tuple2<TrajectoryPoint, TrajectoryPoint> getTrajectorySEPoint(Result result) {
        TrajectoryPoint startPoint = ((TrajectoryPoint) ObjectSerializer.deserializeObject(
                result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.START_POINT_QUALIFIER), TrajectoryPoint.class));
        TrajectoryPoint endPoint = ((TrajectoryPoint) ObjectSerializer.deserializeObject(
                result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.END_POINT_QUALIFIER), TrajectoryPoint.class));
        return new Tuple2<TrajectoryPoint, TrajectoryPoint>(startPoint, endPoint);
    }

    /**
     * 直接获取Result对象中的MBR列
     */
    public static MinimumBoundingBox getTrajectoryMBR(Result result) throws IOException {
        return (MinimumBoundingBox) ObjectSerializer.deserializeObject(
                result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.MBR_QUALIFIER), MinimumBoundingBox.class);
    }
    
    public static TimeLine getTrajectoryTimeLine(Result result) {
        ZonedDateTime startTime = ((TrajectoryPoint) ObjectSerializer.deserializeObject(
                result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.START_POINT_QUALIFIER), TrajectoryPoint.class)).getTimestamp();
        ZonedDateTime endTime = ((TrajectoryPoint) ObjectSerializer.deserializeObject(
                result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.END_POINT_QUALIFIER), TrajectoryPoint.class)).getTimestamp();
        return new TimeLine(startTime, endTime);
    }

    public static boolean isMainIndexed(Result result) {
        return result.getValue(DBConstant.COLUMN_FAMILY, DBConstant.PTR_QUALIFIER) == null;
    }

    public static byte[] getByteArrayByQualifier(Result result, byte[] qualifier) {
        return result.getValue(DBConstant.COLUMN_FAMILY, qualifier);
    }

    public static JSONObject mapTrajectoryToGeoJson(Trajectory trajectory) {
        JSONObject featureCollection = new JSONObject();
        try {
            featureCollection.put("type", "FeatureCollection");
            JSONArray featureList = new JSONArray();
            JSONObject feature = new JSONObject();
            JSONObject geometryObject = convertLineString(trajectory.getPoints());
            JSONObject propertiesObject = convertFeatures(trajectory);
            feature.put("type", "Feature");
            feature.put("geometry", geometryObject);
            feature.put("properties", propertiesObject);
            featureList.add(feature);
            featureCollection.put("features", featureList);
        } catch (JSONException e) {
            LOGGER.info("can't save json object: " + e.toString());
        }
        return featureCollection;
    }

    public static JSONObject mapTrajectoryListToGeoJson(List<Trajectory> trajectoryList) {
        JSONObject featureCollection = new JSONObject();
        try {
            featureCollection.put("type", "FeatureCollection");
            JSONArray featureList = new JSONArray();
            for (Trajectory trajectory : trajectoryList) {
                JSONObject feature = new JSONObject();
                JSONObject geometryObject = convertLineString(trajectory.getPoints());
                JSONObject propertiesObject = convertFeatures(trajectory);
                feature.put("type", "Feature");
                feature.put("geometry", geometryObject);
                feature.put("properties", propertiesObject);
                featureList.add(feature);
            }
            featureCollection.put("features", featureList);
        } catch (JSONException e) {
            LOGGER.info("can't save json object: " + e);
        }
        return featureCollection;
    }

    public static JSONObject convertLineString(List<TrajectoryPoint> points) {
        JSONObject geometryObject = new JSONObject();
        JSONArray coordinateArray = new JSONArray();
        for (TrajectoryPoint point : points) {
            List<Double> temp = new ArrayList<>();
            temp.add(point.getLng());
            temp.add(point.getLat());
            coordinateArray.add(temp);
        }
        geometryObject.put("coordinates", coordinateArray);
        geometryObject.put("type", "LineString");
        return geometryObject;
    }

    public static JSONObject convertFeatures(Trajectory trajectory) {
        JSONObject featuresObject = new JSONObject();
        featuresObject.put("oid", trajectory.getOid());
        featuresObject.put("tid", trajectory.getTid());
        JSONArray timestampArray = convertTrajectoryPointTimestamp(trajectory.getPoints());
        featuresObject.put("timestamp", timestampArray);
        if (!trajectory.isUpdateFeatures()) {
            TrajectoryFeatures trajectoryFeatures = trajectory.getTrajectoryFeatures();
            JSONObject trajFeaturesObject = new JSONObject();
            trajFeaturesObject.put("startTime", trajectoryFeatures.getStartTime().toString());
            trajFeaturesObject.put("endTime", trajectoryFeatures.getEndTime().toString());
            JSONArray coordinateStartArray = convertCoordinate(trajectoryFeatures.getStartPoint());
            trajFeaturesObject.put("startPoint", coordinateStartArray);
            JSONArray coordinateEndArray = convertCoordinate(trajectoryFeatures.getEndPoint());
            trajFeaturesObject.put("endPoint", coordinateEndArray);
            trajFeaturesObject.put("pointNum", trajectoryFeatures.getPointNum());
            trajFeaturesObject.put("whu/edu/cn/trajlab/base/mbr", convertMbr(trajectoryFeatures.getMbr()));
            trajFeaturesObject.put("speed", trajectoryFeatures.getSpeed());
            trajFeaturesObject.put("len", trajectoryFeatures.getLen());
            featuresObject.put("trajectoryFeatures", trajFeaturesObject);
        }
        if (trajectory.getExtendedValues() != null) {
            Map<String, Object> extendedValues = trajectory.getExtendedValues();
            JSONObject extendObject = new JSONObject();
            extendObject.putAll(extendedValues);
            featuresObject.put("extendedValues", extendObject);
        }
        return featuresObject;
    }

    public static JSONArray convertTrajectoryPointTimestamp(List<TrajectoryPoint> points) {
        JSONArray coordinateArray = new JSONArray();
        for (TrajectoryPoint point : points) {
            coordinateArray.add(point.getTimestamp().toEpochSecond());
        }
        return coordinateArray;
    }

    public static JSONArray convertCoordinate(TrajectoryPoint point) {
        JSONArray coordinateArray = new JSONArray();
        coordinateArray.add(point.getLng());
        coordinateArray.add(point.getLat());
        return coordinateArray;
    }

    public static JSONArray convertMbr(MinimumBoundingBox box) {
        JSONArray coordinateArray = new JSONArray();
        List<Double> minCoord = new ArrayList<>();
        List<Double> maxCoord = new ArrayList<>();
        minCoord.add(box.getMinLng());
        minCoord.add(box.getMinLat());
        maxCoord.add(box.getMaxLng());
        maxCoord.add(box.getMaxLat());
        coordinateArray.add(minCoord);
        coordinateArray.add(maxCoord);
        return coordinateArray;
    }
}
